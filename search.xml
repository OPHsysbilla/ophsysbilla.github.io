<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[暂存的工具]]></title>
    <url>%2F2020-11-13-%E6%9A%82%E5%AD%98%E7%9A%84%E5%B7%A5%E5%85%B7.html</url>
    <content type="text"><![CDATA[Visual Studio Code 注意如果hexo s的时候不成功，应该是visual studio code没有保存文件… tips: VS Code缩放在设置里搜索mouseWheelZoom，然后就可以Ctrl+滚轮缩放了 类图contains a 表示整体没有了，部分也没有了 Java如何写类图可以参考[30分钟学会UML类图])(https://zhuanlan.zhihu.com/p/109655171)]]></content>
  </entry>
  <entry>
    <title><![CDATA[惹Java面试答案整理]]></title>
    <url>%2F2020-11-09-%E6%83%B9Java%E9%9D%A2%E8%AF%95%E7%AD%94%E6%A1%88%E6%95%B4%E7%90%86.html</url>
    <content type="text"><![CDATA[ThreadLocal是干嘛的，作用是什么线程池里的参数是什么意思以下内容参考Java线程池实现原理及其在美团业务中的实践 首先检测线程池运行状态，如果不是RUNNING，则直接拒绝，线程池要保证在RUNNING的状态下执行任务。 如果workerCount &lt; corePoolSize，则创建并启动一个线程来执行新提交的任务。 如果workerCount &gt;= corePoolSize，且线程池内的阻塞队列未满，则将任务添加到该阻塞队列中。 如果workerCount &gt;= corePoolSize &amp;&amp; workerCount &lt; maximumPoolSize，且线程池内的阻塞队列已满，则创建并启动一个线程来执行新提交的任务。 如果workerCount &gt;= maximumPoolSize，并且线程池内的阻塞队列已满, 则根据拒绝策略来处理该任务, 默认的处理方式是直接抛异常。 你可能知道的Java知识？ clone()只拷贝第一层，只复制第一层 类比[处理器 - 缓存 - 内存]的三级层次，[线程 - 工作内存 - 主内存]。其中线程互相不可见彼此的工作内存，并通过主内存来共享交流。 volatile关键字的作用是：1、防止指令重新排序；2、保证每个线程在拿到它的那一瞬间前被刷新，拿到的是主内存中的最新值。但不能说volatile修饰了变量后就实现了线程安全：例如i++，i++这个操作本身不是原子性的。线程在拿到i时是可以保证是最新值，但是在之后加一再写回去的这两步中，其他线程可能已经修改了主内存里i的值，最终导致最后写回去的值覆盖了其他线程的操作。 Java中锁的分类有自旋锁、可重入锁、阻塞锁等等分类，其中能够造成线程卡死的锁，只有阻塞锁。 写时复制的ConcurrentHashMap的clear方法是弱一致性的，因为是不同桶结点在清理时临时加锁，所以已经被清理过的段可能会被添加新内容很正常。故现象为clear完后，里面有其他地方新加的数据。原理HashMap? ConcurrentHashMap? 相信看完这篇没人能难住你！和Java 8 ConcurrentHashMap 源码解读 1.接口与抽象类区别？2. java中的异常有哪⼏几类，分别怎么使用？ 摘自地址从根本上讲所有的异常都属于Throwable的子类，从大的方面讲分为Error（错误）和Exception（异常）。Eror是程序无法处理的异常，当发生Error时程序线程会终止运行。我们一般意义上讲的异常就是指的Exception。 3. 常⽤用的集合类有哪些？⽐如list如何排序？4. ArrayList和LinkedList内部实现大致是怎样的？他们之间的区别和优缺点？5. 内存溢出是怎么回事？举个例子。6. ==和equals的区别== 操作符比内存地址equals() 函数比值，可以被继承 7. hashCode()⽅法的作⽤一般用作Hashmap取值，重写equals()必重写hashCode()，并且保证对象为final不变更，出现存取时hashCode()不一致的问题 8. NIO是什什么？适⽤用于何种场景？9. Hashmap实现原理理？如何保证HashMap线程安全？10. jvm内存结构？为什什么需要GC？11. NIO模型，select/epoll的区别，多路复⽤的原理？12. java中⼀一个字符占多少个字节？int，long，double占多少个字节？char 2int 4long/ double / float 8 13. 创建⼀一个类的实例例都有哪些⽅方法？14. final/finaly/finalize区别？15. Session/Cookie区别？16. String/StringBuffer/StringBuilder的区别以及实现？17. Servlet⽣生命周期18. 如何⽤用java分配⼀一段连续的1G的内存空间?需要注意些什什么？19. Java有⾃己的内存回收机制，但为什么还存在内存泄漏的问题呢？20. 什什么是java序列化，如何实现java序列化（写⼀一个例例⼦子）21. String s = new String(“abc”)创建了几个String Object？如果”abc”已经存在于常量池，则只有1个；否则，2个，包含插入常量池的一个； 常量池是JDK1.8里在堆上，此前是在方法区里 new String()究竟创建几个对象? 一个new出来的一个对象new String(xx)，在堆上，内部指向常量池里的内容 深入理解Java：String 22. 静态对象：23. final关键字：24. HashMap与HashTable的区别：25. 多态：26. 集合删除：27. 参数传递与引⽤用传递：28. hash冲突：29. 在java中一个字符能否表示一个汉字：char可以表示一个汉字，char默认两个字节；Java默认UTF-16编码，一个汉字2个字节（UTF-8一个汉字3～4个字节） 30. 一致性hash：31. java反射机制32. 幂等的处理理方式：33. hashmap在jdk1.8中的改动? 冲突时大于8个元素时由链表改为了红黑树 put时是先插入，再判断是否要扩容 resize()时是尾插法，JDK1.7头插法多线程会导致环形链表Infinite Loop 扩容后新位置的计算方式变为 tab[hashCode() &amp; (length - 1)，只用计算多出来的那一位二进制位；因为扩容每次都是2倍大小，ta数组长度保证是2的幂次。JDK1.7的扩容位置计算是重新hash一遍 图文并茂的改动详情见： 美团面试题：Hashmap的结构，1.7和1.8有哪些区别，史上最深入的分析 史上最详细的 JDK 1.8 HashMap 源码解析 34. java 8 流式使⽤用：35. java域的概念： 域（Field），Java里指代的是变量，如类的静态变量和成员变量。初始化的先后顺序 36. jdk1.8中ConcurrentHashMap size⼤于8时会转化成红⿊黑树，请问有什么作⽤，如果通过remove操作，size⼩于8了了，会发⽣什么？ 红黑树可以把链表的时间复杂度O(N)操作转化为O(logN)，查找效率更高； HashMap删除元素时，红黑树树中元素小于UNTREEIFY_THRESHOLD = 6时，会进行树转为链表。static final int UNTREEIFY_THRESHOLD = 6; 37. Hashmap为什么是线程不安全的？在多线程情况下扩容会出现 CPU 接近 100%的情况吗？是因为出现了死循环吗？HashMap在put的时候，插入的元素超过了容量（由负载因子决定）的范围就会触发扩容操作，就是rehash，这个会重新将原数组的内容重新hash到新的扩容数组中，在多线程的环境下，存在同时其他的元素也在进行put操作，如果hash值相同，可能出现同时在同一数组下用链表表示，造成闭环，导致在get时会出现死循环，所以HashMap是线程不安全的 38. hashmap的计算hash值时为什么要用低 16 位与高 16 位进行异或运算用hashCode的高16位和低16位是为了减少碰撞，因为高16位一直没用到：计算下标时会&amp;一个(length - 1)的mask，&amp;操作后只有低位用到了 因为hashmap的hash函数是tab[hashCode() &amp; (length - 1)，等价于tab[ hascode() % length ]，位运算比取模运算的效率要高很多。 同时length永远为2的幂次，所以(length - 1)是一群低位为1的mask。 39. ConcurrentHashMap在JDK1.8的改动是什么？ 去掉了Segment（继承ReentrantLock，只锁部分table） 改为用synchronizied只锁住table，即每个红黑树/链表头，减少锁粒度 Segment下，每个节点都需要通过继承AQS来获得同步支持。但并不是每个节点都需要获得同步支持的，只有链表的头节点（红黑树的根节点）需要同步，这无疑带来了巨大内存浪费– 摘自ConcurrentHashMap(JDK1.8)为什么要放弃Segment Segment数组一旦初始化以后，是不可以扩容的 比如谈谈ConcurrentHashMap1.7和1.8的不同实现中有说到： size()计算方式不同 JDK1.8中使用一个volatile类型的变量baseCount记录元素的个数，当插入新数据或则删除数据时更新baseCount。 实现比1.7简单多，因为元素个数保存baseCount中，部分元素的变化个数保存在CounterCell数组中 JDK 1.7的计算方式是先不加锁，如果多次计算结果相同，则说明无修改；如果多次计算结果都不同，则给每个Segment进行加锁，再计算一次元素的个数；但是已经计算过的Segment可能会被修改 40. synchronizied是可重入锁吗？和ReentrantLock区别是什么？ ReentrantLock的锁实现是用aqs,会占用额外空间.synchronizied是底层的jvm的线程竞争. 41. String为什么避免在循环里用+拼接因为每次执行“+”操作时jvm都要new一个StringBuffer对象来处理，最后用[StringBuffer].toString()得到最终的值 42. JVM类加载机制特点1. 全盘负责， 2. 双亲委派机制，先让父类加载器试图加载该类 3. 缓存机制，一次加载后类加载存在缓存里 要判断两个类是否“相同”，就算包路径完全一致，但是加载他们的ClassLoader不一样，那么这两个类也会被认为是两个不同的类 可以加载类的时候，对字节码进行修改吗？Java探针-Java Agent技术-阿里面试题 JVM类加载过程，什么是双亲委派机制？ 吊打面试官-类加载器 加载(ClassLoader的loadClass()方法) 类的全限定名(如cn.edu.hdu.test.HelloWorld.class)读取二进制字节流 将其转换为运行时数据结构(存储到方法区中) 内存中生成一个java.lang.Class对象来作为这个类的入口 连接(Linking) 验证 文件格式（是否以魔术0xCAFEBABE开头）、 元数据（这个类是否有父类）、 字节码、 符号引用验证（确保解析动作能进行） 准备为类中的所有静态变量分配内存空间，初始默认值 （static int a = 123;准备阶段时默认为0，而String b = &quot;xx&quot;; 为null ） 用final修饰的静态字段在准备阶段就被初始化为一个编译时常量表达式 解析将常量池中所有的符号引用转为直接引用（得到类或者字段、方法在内存中的指针或者偏移量，以便直接调用该方法） 这个阶段是唯一可以推迟在初始化之后再执行的，Class.loadClass()执行完获得的对象是连接后的对象。 初始化 没有静态块编译器可以不生产&lt;clinit&gt;()函数 接口与类不同的是，执行接口的&lt;clinit&gt;()方法不需要先执行父接口的&lt;clinit&gt;()方法 &lt;clinit&gt;静态变量初始化顺序由语义顺序决定 多线程调用不同类的&lt;clinit&gt;时JVM会保证线程安全，也因此会阻塞；可以利用静态内部类实现线程安全的单例模式 父类静态 - 父类构造函数 - 子类静态 - 子类构造函数 使用 卸载 该类所有的实例都已经被GC 加载该类的ClassLoader已经被GC。 该类的java.lang.Class 对象没有在任何地方被引用，包括反射 何时触发初始化 为一个类型创建一个新的对象实例时（比如new、反射、序列化） 调静态方法 赋值或读取类或接口的静态字段 用final修饰的静态字段除外，常量会在编译阶段存入调用类的常量池中 调用JavaAPI中的反射方法时（比如调用java.lang.Class中的方法，或者java.lang.reflect包中其他类的方法） 初始化一个类的派生类时（超类必须提前完成初始化操作，接口例外） JVM启动包含main方法的启动类时。 类的生命周期是什么？加载器什么时候会被unload？类的生命周期就是从类的加载到类实例的创建与使用，再到类对象不再被使用时可以被GC卸载回收。由java虚拟机自带的三种类加载器加载的类在虚拟机的整个生命周期中是不会被卸载的，只有用户自定义的类加载器所加载的类才可以被卸载。 说说Java内存回收年轻代：主要用来存放新创建的对象，年轻代分为eden区和两个Survivor区。大部分对象在Eden区中生成。当Eden区满时，还存活的对象会在两个Survivor区交替保存，达到一定次数的对象会晋升到老年代 jvm的内存模型和java的内存模型Java内存模型（Java Memory Model）与并发问题相关 保证共享内存的正确性(可见性、有序性、原子性) 缓存一致性：多线程的场景中，每个核都至少有一个L1 缓存。所有的变量都存储在主内存中，每条线程还有自己的工作内存，线程的工作内存中保存了该线程中是用到的变量的主内存副本拷贝。 volatile修改后将新值同步回主内存，在变量读取前从主内存刷新变量值 synchronized关键字保证同一时刻只允许一条线程操作，同时保证可见性、有序性、原子性，通过monitorenter和monitorexit的monitor锁来确保。 final关键字则不可修改什么是内存屏障？是为了解决什么问题？刷新缓存或禁用指令重排序指令，解决不同线程并发读写主存同一个位置时缓存一致性的问题 JVM的内存模型栈帧、操作数栈和局部变量表分别都是什么作用呢？1234基于栈的指令集系统可以很方便的做到平台无关性(x86、arm)即使是赋值也要执行两次出栈操作这也是为啥Java性能比C低的原因因为操作寄存器快比操作栈快 局部变量表 编译为Class文件时，方法的Code属性中的max_locals中确定了该方法所需分配的局部变量表的最大容量。每个表项容量(Variable Slot)为32位，64位的数据则占用2个表项。 操作数栈(Operand Stack)，一个后入先出栈(LIFO) 栈的最大深度在编译的时候写入到方法的Code属性的max_stacks数据项中 动态连接 推迟到运行期，将方法的符号引用转化为内存地址的偏移量直接引用 静态解析：类加载阶段或者第一次使用时就直接转化为直接引用，这类转化称为 方法返回地址 正常退出（没有抛出任何异常） 把当前栈帧出栈，把返回值压入调用者的操作数栈中。恢复上下文。 恢复上下文 ：包括恢复上层方法的局部变量表和操作数栈，调整PC计数器的值以指向方法调用指令后的下一条指令 异常退出 方法异常退出时，返回地址是通过异常处理器表确定的 方法正常退出时，调用者的PC计数值可以作为返回地址，栈帧中可能保存此计数值。 内存的可见性与java内存模型对原子性、可见性、有序性的保证机制；Jvm调优 常用的gc算法的特点、执行过程，和适用场景。例如g1适合对最大延迟有要求的场合，zgc适用于64为系统的大内存服务中； 常用的jvm参数，明白对不同参数的调整会有怎样的影响，适用什么样的场景。例如垃圾回收的并发数、偏向锁设置等； 在编程时如何合理利用栈上分配降低gc压力、如何编写适合内联优化等代码（编译方向） 线上经常full gc问题，排查过内存泄露问题（线上实际问题的排查经验） 高并发低延迟的场景，如何调整gc参数尽量降低gc停顿时间，针对队列处理机如何尽可能提高吞吐率等（特定场景的jvm优化实践或者优化） 解zgc高效的实现原理，了解Graalvm的特点（jvm最新技术）]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机网络常见面试整理]]></title>
    <url>%2F2020-11-09-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E6%95%B4%E7%90%86.html</url>
    <content type="text"><![CDATA[长连接和短连接是什么？为什么是必要的？心跳包作用及格式作用是保持长连接避免不断创建tcp连接 心跳包格式的定义及处理报文头的定义，就是你发送数据的时候需要先发送报文头，报文里面能解析出你将要发送的数据长度你发送数据包的格式，是json的还是其他序列化的方式 Socket连接池干嘛的Socket连接池，就是维护着一定数量Socket长连接的集合。它能自动检测Socket长连接的有效性，剔除无效的连接，补充连接池的长连接的数量 Http加密过程是怎样的让第三方CA来确保server公钥正确 1）server向CA提供基本信息、公钥等，CA用CA私钥对server公钥和信息进行加密形成数字证书（防止server被伪造）。2）client向server发出https请求和随机数c，server返回数字证书和随机数s。3）client收到数字证书，用CA公钥对数字证书进行解密，得到server的公钥。 得到server公钥后，client可以用server公钥解密server签名得到摘要。client也把原文hash一遍得到的摘要比对，确认内容没有经过更改 生成会话密钥client用server公钥加密client生成的随机数premaster secret，发送给server。server收到加密的随机数premaster secret，用server私钥解密随机数，然后和随机数c、随机数s一起生成会话密钥。此时client也拥有三个随机数生成相同的会话密钥(Session Key)。双方用会话密钥进行加密通信（防止内容被窃听进行加密） 用会话密钥(Session Key)进行加密通信是对称加密的。如DES，AES等对称加密，只有一把钥匙而获得会话密钥的过程是不对称加密的。最常见的非对称加密是RSA，有公钥和私钥，公钥加密只有私钥解密，私钥加密只有对应公钥解密 如何防止数据被篡改 数字签名是server对通信内容进行hash，得到信息摘要。 然后用server私钥对摘要进行加密得到数字签名。server把明文连同数字签名一起发送给client client用server公钥对数字签名解密得到信息摘要，然后用相同的hash对数据进行计算得到信息摘要，比对两个信息摘要是否一致。 tcp三次握手问题为什么TIME_WAIT状态还需要等2MSL后才能返回到CLOSED状态？TIME_WAIT状态的作用就是用来重发可能丢失的ACK报文。 虽然双方都同意关闭连接了，但网络是不可靠的，你无法保证你最后发送的ACK报文会一定被对方收到，因此对方处于LAST_ACK状态下的Socket可能会因为超时未收到ACK报文，而重发FIN报文 TIME_WAIT状态所导致的服务器问题一台机器上端口号数量的上限是65536个，TCP服务器最大并发连接数是多少？。 如果在同一台机器上进行压力测试模拟上万的客户请求，并且循环与服务端进行短连接通信，那么这台机器将产生4000个左右的TIME_WAIT Socket，后续的短连接就会产生address already in use : connect的异常 如果使用Nginx作为方向代理也需要考虑TIME_WAIT状态，发现系统存在大量TIME_WAIT状态的连接，通过调整内核参数解决。 HTTPDNSAndroid Webview + HttpDns最佳实践DNS优化 - 百度的HTTPDNS大部分标准DNS都是基于UDP与DNS服务器交互的，HTTPDNS则是利用HTTP协议与DNS服务器交互 摘要一则：对于客户端同学，我们在PC上要学会使用tcpdump和Wireshark等工具，适当使用Fiddler和Charles等工具，很多时候电脑和手机的网络环境不见得一致，所以要在手机上使用iNetTools，Ping&amp;DNS或终端工具。学会使用工具后，要学着创造不同的网络环境，有很多工具能帮助你完成这点，比如苹果的Network Link Conditioner，FaceBook的ATC（Augmented Traffic Control）等 负载均衡nginx负载均衡调度算法默认是 round robin，也就是轮询调度算法12345678910j = i;do&#123; j = (j + 1) mod n; if (W(Sj) &gt; 0)&#123; i = j; return Si; &#125;&#125; while (j != i);return NULL; 压缩算法用的是什么？客户端发送Accept-Encoding，服务端回应123456789Accept-Encoding: gzip, compress, brAccept-Encoding: br;q=1.0, gzip;q=0.8, *;q=0.1（除了 identity 之外，都是无损压缩）gzip：表明实体采用 GNU zip 编码。（gzip 对媒体文件的压缩效果相对较差）compress：表明实体采用 Unix 的文件压缩程序。deflate：表明使用是用 zlib 的格式压缩的。br：表明实体使用 Brotli 算法的压缩格式。identity：表明没有对实体进行编码，为默认值。 具体说明见Accept-Encoding]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android面试答案整理]]></title>
    <url>%2F2020-11-09-Android%E9%9D%A2%E8%AF%95%E7%AD%94%E6%A1%88%E6%95%B4%E7%90%86.html</url>
    <content type="text"><![CDATA[Retrofit(动态代理)说说组件化和插件化，热更新技术原理知识图谱 Android初级、中级、高级、资深工程师(架构师、专家)技能图谱 面试官: 说一下你做过哪些性能优化? Binder怎么学 为什么Binder的通信只进行了一次拷贝 聊聊怎样学习Binder内有c++代码简单传输的过程 理解AIDL中的in，out，inout吗 一文看得懂的源码：聊聊怎样学习Binder 一文超翔实的源码：Android Bander设计与实现 - 设计篇 Android ANR的产生原因，如何定位ANRHandler 40问摘自面试常客「Handler」的 40+ 个高频问题 Q &amp; A 对答！ OkHttp相关断点续传 客户端请求 Range: bytes=200-1000 见Range 服务器返回 206 Partial Content 标示Content-Range: bytes 200-1000/67589 同时服务器响应的header中有Accept-Ranges: bytes 使用RandomAccessFile允许自由定义文件记录指针，在同一个文件的不同位置进行并发读写 客户端头的 If-Range 需要和 Range 配合起来使用，否则会被服务端忽略 以下摘自 图解：HTTP 范围请求，助力断点续传、多线程下载的核心原理： 范围请求需要 HTTP/1.1 及之上支持 客户端通过在请求头中添加 Range 这个请求头，来指定请求的内容实体的字节范围。 服务端通过 Content-Range 来标识当前返回的内容实体范围，并使用 Content-Length 来标识当前返回的本次压缩后要读多少字节。 客户端可以通过 If-Range 来区分资源文件是否变动，它的值来自 ETag 或者 Last-Modifled。如果资源文件有改动，服务器会返回code 200重新走下载流程。 为什么多线程下载可以提速见这篇文章：撸了个多线程断点续传下载器，我从中学习到了这些知识个人理解，当发生了丢包，检测到拥塞时，TCP慢启动会减半线性增长发送窗口。而多线程一起下载，其他线程可能正在正常下载，只影响发生丢包的线程 请求队列的使用的线程池Dispatcher类里有两个异步队列，一个同步队列，readyAsyncCalls是没排上队的请求。 没排上队是因为在进队时，目前正在执行的请求大于64或者同Host的请求大于5了，参考线程池的思想。runningSyncCalls和runningAsyncCalls都是正在执行（包括已经取消但没结束）的请求，区别是一个同步一个异步。结束后。在每个请求停止后会去promoteCall()，遍历readyAsyncCalls能够执行执行，放进runningAsyncCalls里。和线程池里的Worker一个套路。 okhttp责任链，递归调用拦截器根据网络的分层思想，把每一步要做的操作顺序排列为一个list。每个拦截器(Intercept)都要手动调用chain.proceed()去调用list里下一个index的拦截器(Intercept)来达到调用下一层的效果，并递归返回response。 除了发起真正的网络请求的CallServerInterceptor，它不用调用下一层，只用递归返回response 应用拦截器interceptors和网络拦截器networkInterceptors的区别在哪区别在应用拦截器是在整个操作前，网络拦截器是在真正请求前由于有多次重试等拦截器的存在，一般应用拦截器只会执行一次，网络拦截器可能会走很多次1234567891011121314151617181920212223242526Response getResponseWithInterceptorChain() throws IOException &#123; // Build a full stack of interceptors.interceptors List&lt;Interceptor&gt; interceptors = new ArrayList&lt;&gt;(); interceptors.addAll(client.interceptors());//应用拦截器 //重定向、重试 interceptors.add(retryAndFollowUpInterceptor); //用户应用层和网络从桥梁。主要包含： //1. 将用户的request，转变为网络层的request，比如添加各种请求头，UA ,Cookie , Content-Type等。 //2. 将网络层的response转变为用户层的response，比如解压缩，除去各种请求头等。 interceptors.add(new BridgeInterceptor(client.cookieJar())); //缓存 interceptors.add(new CacheInterceptor(client.internalCache())); //负责与服务器之间建立连接。 interceptors.add(new ConnectInterceptor(client)); if (!forWebSocket) &#123; interceptors.addAll(client.networkInterceptors());//网络拦截器 &#125; //负责请求服务器 interceptors.add(new CallServerInterceptor(forWebSocket)); //第一个chain Interceptor.Chain chain = new RealInterceptorChain( interceptors, null, null, null, 0, originalRequest); //通过链式请求的得到response return chain.proceed(originalRequest); &#125; OKHTTP Socket连接池复用Http连接减少请求延迟。避免网络连接的时延，以及避免TCP调谐带来的带宽过小的问题。okhttp记录了每个socket流使用情况，同时设定了每个socket能同时使用多少流。 socket复用有何标准 共享socket,HTTP/2支持所有连接到同一个主机的请求共享socket 对每个socket来说： host完全一样，可以直接复用return true 没有达到socket连接池复用数量的总上陷，且这个socket流还没有关闭 okhttp只在2.0的时候会复用 有相同IP地址的（说明两个对比的连接都已经DNS得到过IP），且没有使用代理，有了代理就不知道最初的IP是多少了 复用socket连接意味着跳过了https握手，所以要验证证书，如果证书可以覆盖的话，IP不一样也可以 一个socket如果被复用，只有http2.0允许同一个socket在同一个时候写入多个流数据。http1.x协议下当前socket没有其他流正在读写时可以复用，http2.0对流数量没有限制 http1.x在http 1.x协议下，所有的请求的都是顺序的，即使使用了管道技术（可以同时按顺序连续发送请求，但消息的返回还是按照请求发送的顺序返回）也是如此，因此一个socket在任何时刻只能有一个流在写入，这意味着正在写入数据的socket无法被另一个请求复用 http2.0http2.0协议使用了多路复用技术，允许同一个socket在同一个时候写入多个流数据，每个流有id，会进行组装，因此，这个时候正在写入数据的socket是可以被复用的。 一个socket何时会被关闭？socket池何时被清理okhttp通过一个单独的线程来清理socket池。每次put一个新连接的时候都会判断当前是否有在清理socket池。这个线程while(true)循环找出空闲时间最长的sockect连接，默认可以保存5个空闲线程，并且5分钟内依旧空闲的话，将被关闭回收。 规定时间t = sockect默认设定的生存时间 如果哪个空闲连接超过了规定时间t，关掉这个socket，立刻返回继续找下一个 如果每个空闲连接都没有超过规定时间t的，就返回空闲时间最长的sockect连接，得到diff = 规定时间 - 空闲时间，开始wait(diff)，wait()完后继续下一次清理 如果没有空闲连接， 最少wait()等待一个规定时间t 没有任何连接，返回-1退出while(true)，等待下次put个新连接的时候的时候重新开启清理socket池的线程只要连接池中有连接，基本清理线程就一直存在，直到所有连接被释放该线程才会停止 清理的线程池okHttp使用的是：123private static final Executor executor = new ThreadPoolExecutor(0 /* corePoolSize */, Integer.MAX_VALUE /* maximumPoolSize */, 60L /* keepAliveTime */, TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;(), Util.threadFactory("OkHttp ConnectionPool", true)); 和newCachedThreadPool一样，可以动态添加到无限大的，用的SynchronousQueue当等待队列所以新来的线程没有地方去就会阻塞住，直到开了一个空线程来执行。Okhttp3 总结研究 （面试） OkHttp的HTTP缓存主要是根据Header(Date\Expires\Last-Modified\ETag\Age)来缓存响应数据减少重复的网络请求 点击桌面图标进入我们软件应用时发生了什么？通过翻阅 Application 启动的源码，当我们点击桌面图标进入我们软件应用的时候，会由 AMS 通过 Socket 给 Zygote 发送一个 fork 子进程的消息，当 Zygote fork 子进程完成之后会通过反射启动 ActivityThread##main 函数，最后又由 AMS 通过 aidl 告诉 ActivityThread##H 来反射启动创建Application 实例，并且依次执行 attachBaseContext 、onCreate 生命周期，由此可见我们不能在这 2 个生命周期里做主线程耗时操作。 OOM是什么，怎么导致的？ java.lang.OutOfMemoryError: Java heap space ——&gt;java堆内存溢出，此种情况最常见，一般由于内存泄露或者堆的大小设置不当引起。对于内存泄露，需要通过内存监控软件查找程序中的泄露代码，而堆大小可以通过虚拟机参数-Xms,-Xmx等修改。 java.lang.OutOfMemoryError: PermGen space ——&gt;java永久代溢出，即方法区溢出了，一般出现于大量Class或者jsp页面，或者采用cglib等反射机制的情况，因为上述情况会产生大量的Class信息存储于方法区。此种情况可以通过更改方法区的大小来解决，使用类似-XX:PermSize=64m -XX:MaxPermSize=256m的形式修改。另外，过多的常量尤其是字符串也会导致方法区溢出。 java.lang.StackOverflowError ——&gt; 不会抛OOM error，但也是比较常见的Java内存溢出。JAVA虚拟机栈溢出，一般是由于程序中存在死循环或者深度递归调用造成的，栈大小设置太小也会出现此种溢出。可以通过虚拟机参数-Xss来设置栈的大小。 事件分发 Android事件分发机制 详解攻略，您值得拥有 如何减少卡顿？刷新原理 Glide是如何监听周期的？监听生命周期用了一个没有UI的Fragment（名为RequestManagerFragment）入到传入的非Application的Context的FragmentManager中 监听传入的Context的AcitivityLifeCycle（由RequestManager实现的事实上） 监听网络状态依然是用上面的fragment的AcitivityLifeCycle回调达到的 在onStart和onStop的时候分别注册、反注册网络状态的监听，来达到在变得有网的情况下重启请求的目的 监听内存状态在Glide构造的时候会调用registerComponentCallbacks进行全局注册 registerComponentCallbacks是ApplicationContext提供具有内存过低等时机的回调（onTrimMemory、onLowMemory、onConfigurationChanged） 在onTrimMemory时，会依次执行： 123memoryCache.trimMemory(level);bitmapPool.trimMemory(level);arrayPool.trimMemory(level); 两个Activity切换生命周期是怎样的？]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode题目思考与记录]]></title>
    <url>%2F2020-02-29-leetcode%E9%A2%98%E7%9B%AE%E6%80%9D%E8%80%83%E4%B8%8E%E8%AE%B0%E5%BD%95.html</url>
    <content type="text"><![CDATA[约瑟夫环问题 见此 单调栈 42. 接雨水 84. 柱状图中最大的矩形 保卫王国 - 牛客 无损压缩算法：deflate、Huffman Coding寻找两个有序数组的中位数要求算法的时间复杂度为 O(log(m + n))即找出第(m+n)/2个元素设k=(m+n)/2，则需要在两个数组中分别寻找第k/2个元素，原因如下： 题目中要求的时间复杂度为 O(log(m + n))，很容易想到的方法就是二分，现在有两个数组，要对那个数组进行二分合适？由于找的是中位数，那么这个数字的两边的元素个数是相等的，所以只需要确定一个数组中的两边元素，两一个数组的对应的补上去就可以了，为了提高效率，要选择最短的数组做二分查找 — 原文 为什么Java中int型数据取值范围是[-2^{31}, 2^{31}-1]为什么Java中int型数据取值范围是[-2^{31}, 2^{31}-1] 判断一个有符号int型整数是不是溢出：x &gt; INT_MAX / 10 || x == INT_MAX &amp;&amp; x 10 + 7 就会溢出x &lt; INT_MIN / 10 || x == INT_MIN. &amp;&amp; x 10 + 8 就会溢出 反转数字push一位数字x：int res = res * 10 + xPop一位数字：res /= 10需要警惕是否溢出 Lru最近访问Lru在Java里就是LinkedHashMap有序字典，每次get/put后把该元素挪动到双向链表尾。双向链表是因为方便删除，是所有数据的。、 动态规划2、3、5硬币面值（无限个数），构成总数为k的方法数和上楼梯很像，区别在于上楼梯只是1、2两步 上楼梯的状态方程： dp[0] = dp[1] = 1, dp[i] = dp[i-1] + dp[i-2] (i &gt; 2)。设置dp[0] = 1只是为了后续好加；这一题就是dp[1] = 1, dp[i] = dp[i-2] + dp[i-3] + dp[i-5]，意义是为了总数为i的金额是由i-2的情况和i-3和i-5的情况达成的 trim树 - 搜索自动补全TSP问题三重dp拓扑 + ？]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>Algorithm</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库面试答案]]></title>
    <url>%2F2019-07-04-%E6%95%B0%E6%8D%AE%E5%BA%93%E9%9D%A2%E8%AF%95%E7%AD%94%E6%A1%88.html</url>
    <content type="text"><![CDATA[子查询的数据库效率差别比较 in和or区别在需要使用的这个栏位所在的列为索引或者主键时，使用in或者or的区别不是很大。在没有索引的情况下，随著in或者or的数量越来越多，in的效率不会有很大的下降，但是or会随著记录越来越多的情况下效能下降很快。 not exists 和 not in 比較時，not exists 的效率比較高 in是先执行子查询中的查询，然后再执行主查询，故适合于外表大而内表小的情况。in时不对NULL进行处理。 exists查询它是先执行主查询，即外层表的查询，然后再执行子查询，故适合于外表小而内表大的情况。 当使用in时，子查询where条件不受外层的影响，自动优化会转成exist语句，它的效率和exist一样。如select * from t1 where f1 in (select f1 from t2 where t2.fx=’x’) 这时，认为in 和 exists效率一样 一些常见的sql性能问题]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[当你发现自己不知道做什么...]]></title>
    <url>%2F2019-01-28-%E5%BD%93%E4%BD%A0%E5%8F%91%E7%8E%B0%E8%87%AA%E5%B7%B1%E4%B8%8D%E7%9F%A5%E9%81%93%E5%81%9A%E4%BB%80%E4%B9%88.html</url>
    <content type="text"><![CDATA[去看面试笔记吧！有目标才能快速发现自己不会什么~ 2018年年底Android悲催的面试之路 what we need to know 关于Handler的拦截里有谈到，调用callback的时候是根据顺序选择一个来调用的。 优先调用Message中的Callback，再来调用Handler的全局Callback；如果没有全局mCallback，或者全局mCallback返回false不拦截，则调用Handler的handleMessage epoll_wait是什么唤醒机制？ 系统是如何监听ANR的? 应用发生卡顿，一定是在dispatchMessage中执行了耗时操作。通过给主线程的Looper设置一个Printer，计算方法运行前后两次打印的时间差是否超过阈值来判断是否有ANR。tips： /data/anr/traces.txt中会保存一个最近ANR的信息。 ThreadLocal所操作的变量只存在于各自的线程里，每一个线程都有一个ThreadLocal且拿到的变量是不同的。每个Thread的对象都有一个ThreadLocalMap，当创建一个ThreadLocal的时候，就会将该ThreadLocal对象添加到该Map中，其中键就是ThreadLocal，值可以是任意类型 《深入理解java虚拟机》周志明，P396原文：要保证线程安全，并不一定就是要进行同步，两者没有因果关系。同步只是保证共享数据争用时的正确性的手段。如果一个方法本来就不涉及共享数据，那它自然就无需任何同步措施去保证正确性 在华为的好多手机会OOM是由线程数溢出引起如何解决？java.lang.IllegalArgumentException: register too many Broadcast Receivers，华为5.0+的手机发送超过500个广播就会出现这个问题，因为它内部有白名单，只允许白名单中的应用（微信）发500个广播。这篇绕过华为register too many Broadcast Receivers限制里有用到一些插件化的知识，推荐阅读插件加载机制]]></content>
  </entry>
  <entry>
    <title><![CDATA[Android踩过的坑]]></title>
    <url>%2F2019-01-25-Android%E8%B8%A9%E8%BF%87%E7%9A%84%E5%9D%91.html</url>
    <content type="text"><![CDATA[从AutoScroll的View说起Scroller的原理与作用二话不说，先看看判断RecyclerView是否滚动到底部中说到的computeVerticalScrollExtent()函数表示的View内容与View位置的相对滚动 错误使用PorterDuffXferMode后效果并没有得到想要的效果！-&gt; 关了硬件加速还是不行555 为何和谷歌给的样子不同？因为谷歌写的demo里，是两个高宽一样的bitmap在相交，如果发现有多余的位置没有被遮住，说明两个相交的位置不一样。 源图像在运算时，只是在源图像所在区域与对应区域的目标图像做运算。所以目标图像与源图像不相交的地方是不会参与运算的！这一点非常重要！不相交的地方不会参与运算，所以不相交的地方的图像也不会是脏数据，也不会被更新，所以不相交地方的图像也永远显示的是目标图像。 —— 《Android高级进阶——绘图篇（五）setXfermode 设置混合模式》 谁是源图像谁是目标图像123456//绘制 目标图像canvas.drawBitmap(dstBitmap, 100, 100, paint);//设置 模式 为 SRC_OUTpaint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.SRC_OUT));//绘制源图像canvas.drawBitmap(srcBitmap, 100, 100, paint); 任何和空白透明像素相交的结果都是空白透明像素哦所以SRC_OUT等需要有颜色，而不是透明的。比如SRC_OUT时需要添加颜色。 例子 用蒙版做了一个指针指示，里面有提到关于带透明度的混合模式与谷歌给的Api展示的区别：Android 混合模式 —— PorterDuffXferMode 基于谷歌Api的demo修改了让你测试：Canvas绘图之PorterDuffXfermode使用及工作原理详解 给了一个demo让你自己尝试不同的效果： 关于 Xfermode 正确理解姿势 做了一个DST_ATOP的例子：android遮罩Xfermode的学习 解释了SRC_OUT：通过消除背景层与重叠部分绘制组合图形 到底有没有在用心学ndk啊 JNIEnv*env 是一个线程对应一个env，线程间不可以共享同一个env变量。JNI中Fatal signal 11 (SIGSEGV), code 1的错误 可以使用Android自带的addr2line来分析native的行信息Android通过addr2line工具分析native crash log 注意lock后再wait该锁的问题JVM故障分析系列之五：常见的Thread Dump日志案例分析 使用SurfaceView时需要注意 All SurfaceView and SurfaceHolder.Callback methods will be called from the thread running the SurfaceView’s window (typically the main thread of the application). They thus need to correctly synchronize with any state that is also touched by the drawing thread. You must ensure that the drawing thread only touches the underlying Surface while it is valid – betweenSurfaceHolder.Callback.surfaceCreated() andSurfaceHolder.Callback.surfaceDestroyed(). 硬件加速？ Android里所有View控件以自定义View所使用得Canvas是硬件加速的（使用 GPU 进行加速，在 Android 上一般就是指会使用 OpenGL 进行绘制），Surface.lockCanvas获取的就是关闭硬件加速的Canvas。见OpenGL中 Canvas 性能分析 SurfaceView/TextureView的区别 SurfaceView是一个有自己Surface的View。界面渲染可以放在单独线程而不是主线程中。它更像是一个Window，自身不能做变形和动画。 TextureView同样也有自己的Surface。但是它只能在拥有硬件加速层层的Window中绘制，它更像是一个普通View，可以做变形和动画。 普通View都是共享一个Surface的，所有的绘制也都在UI线程中进行，因为UI线程还要处理其他逻辑，因此对View的更新速度和绘制帧率无法保证。这显然不适合相机实时 预览这种情况，因而SurfaceView持有一个单独的Surface，它负责管理这个Surface的格式、尺寸以及显示位置，它的Surface绘制也在单独的线程中进行，因而拥有更高 的绘制效率和帧率。 非UI线程使用View.post，可能会导致内存泄漏 在API低于24的版本上，非UI线程使用View.post，可能会导致内存泄漏。因为子线程调用View.post()，如果view还未attach到window，只有UI线程的performTraversals才会去把runnable拿出来执行，子线程没有performTraversals，故这个runnable将永远不会执行。 文章中最后给出的结论是，要保持兼容 API 24 以下的版本，最好不要在非 UI 线程使用 View.post ，而采用 Handler 来 post runnable。 当然在 API 24 及以上，如果不能保证 View 一定会被 attach，那可以在引用对象销毁时，使用 View.removeCallbacks。 Fragment的坑 子fragment中写了listener，父fragment设置子fragment的listener，然后横竖屏切换时，listener会报空： 在activity被异常回收之后，如果没有设置onConfigurationChange，activity会重建完整再走一遍生命周期的流程。onSaveInstanceState方法被调用的时候，已经add到FragmentManager中的fragment不被释放，旧的fragment的内存实例始终存在，且view也始终在展示并不会被destroy，因此需要在Acitivty的onCreate()和onSaveInstanceState()处添加代码：123if (savedInstanceState != null) &#123; savedInstanceState.remove("android:support:fragments");&#125; Android Studio 的新东西 find . | grep hprof-conv 在~\Library\Android\sdk\下找出hprof-conv的位置，再使用命令./hprof-conv -z infile outfile 来转换成Eclipse的Mat工具能够识别的hprof文件，注意使用此命令时，指定的outPutFile路径需要已经被创建，否则会一直返回Usage…展示Usage: hprof-conf [-z] infile outfile 强行刷新gradle依赖缓存，拉取远程依赖版本：./gradlew build --refresh-dependencie。 只想刷新某个指定的依赖: 直接去~/.gradle/caches/modules-2目录下，rm -fr find . -name xxx，然后直接重编删除含有’aaa’的文件夹依赖：find ~/.gradle/caches -type d | grep &#39;aaa&#39; | xargs rm -r CoordinaryLayout-Behavior达成滑动联动特效 Android常规的Touch事件传递机制是自顶向下，由外向内的，一旦确定了事件消费者View，随后的事件都将传递到该View。因为是自顶向下，父控件可以随时拦截事件，下拉刷新、拖拽排序、折叠等交互效果都可以通过这套机制完成。Touch事件传递机制是Android开发必须掌握的基本内容。但是这套机制存在一个缺陷：子View无法通知父View处理事件。NestedScrolling就是为这个场景设计的。 ———— Android Nested Scrolling 在Window上做动画：Acitivity间自定义动画的可能性这两天一直在想做一个Activity间的转场动画可以对单个view进行自定义动画的。因为ShareElement动画不支持5.0以下，所以开始思考其他的方法。读了通过WindowManager添加view以及添加动画后发现其实shareElemet也是在做假动画，本activity一次假动画，下一个Activit一次假动画。这篇Android WindowManager及其动画问题中说到，在WindowManager上像在Activity中使用动画效果无效，目前还没细看。 发现了一个特殊的效果..图凌闪屏页及Android彩蛋探究目前的结论还是做假的动画比较靠谱…]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法简明笔记]]></title>
    <url>%2F2019-01-23-%E7%AE%97%E6%B3%95%E7%AE%80%E6%98%8E%E7%AC%94%E8%AE%B0.html</url>
    <content type="text"><![CDATA[简略地描述思路，以供后来观之 本笔记只是备忘录，并不是详细解决方案，请使用ctrl+F查询 Algorithm1. 打印字符串全排列递归后需要马上还原（因为所有的），因为递归是一颗深度优先的树（也就是栈），是先从叶子开始改变的 2. 二叉搜索树转为双向链中序遍历二叉搜索树正好是递增的，只需要把结点左右指针连接中序中前后的结点。（二叉搜索树没有相同值的点） 3. 递归求排列求排列时若用递归法，递归叶子回溯到父亲时需要还原改变（叶子最先改变，也就是说是从字符串数组最后两位开始的），不然就不是同一串字符串出发的（画出排列树推吧） 3. 复制复杂链表每个结点复制一个接在该结点后面，a-&gt;a’-&gt;b-&gt;b’-&gt;c-&gt;c’，同时复制原结点所指向的任意结点，最后奇偶结点分离（跳着分离） 4. 最小的k个数 partition函数（快排）最后得到的index就是他在序列中的位置，左边的就是前index个数。（期间可以用二分法逐渐缩小区间，由于是用一个固定位置的数作pivot所以最后得到的index是针对整个数组而言的） 5. 集合和最大堆基于红黑树6. 最大子数组和如果累加和为负则重新从新元素开始 7. 从1到n数里包含1的个数O(log10N) ， 十位上，每轮出现10次是指[10,19]这10个数 解析 8. 逆序对归并排序的同时进行计数 9. 数组排成最小的数可以用sprintf将数字写入字符串 10. 二叉树最低公共祖先（若是二叉搜索树）比一个结点大，比另一个结点小；（若有指向父节点的指针）寻找两个链表的公共结点；（什么都不是）用栈递归到叶子再逐个往上退栈。 11. 二叉树路径和等于某个数传递vector的引用（用vector作栈方便顺序输出），递归遍历，进入结点时压入该结点，退出时弹出（恢复成父节点进入的情景） 12. 不能继承的类虚拟继承virtual 父类，把父类构造函数设为私有，并且父类含有一个友元函数，友元函数的类型是由模板类给出的，所以虚拟继承的时候需要把子类的类型当成参数传入；（只能在堆上）私有构造与析构，用静态getInstance函数返回一个新的父类对象。 13. C++按类中声明的元素顺序初始化成员14. 求方程正整数解个数求方程正整数解个数 15. 多路平衡归并排序外排序，m个归并项（子表个数）k路归并的归并趟数s=logk(m)，败者树 16. n阶乘末尾0的个数（n除以5，即求5的质因数个数）存在0必然是52的结果，所以必然含有5!(5432*1)，所以只要求多少个5的倍数即可 17. mongodb为什么没有自增id因为并发情况下同时插入,分布式存储的情况下无法协调分配连续数字（协调需要消耗网络资源），并且内部也不是按id顺序存的，因为文档长度可变，不知道什么时候文档变长要放到后面去 18. 数n的约数个数（约数：能把别人整除的叫约数）自然数的约数的个数是有限的，质数的约数是1和本身；合数一定有3个以上的约数。由于约数个数定理知道：约数的个数等于:所有质因数的指数加上1后的乘积;若一个数分解质因数后为(a^m)*(b^n),其中a,b均为质因数;m,n均为相应质因数的指数.则约数个数为(m+1)(n+1).(因为a^0,a^1 … a^m，都是它的约数共m+1个) 例如:(1)12=2^2 3,质因数有2和3,其指数分别为2和1,那么12的约数有(2+1) (1+1)=6(个);(2)60=22 3 5,质因数2, 3, 5的指数分别为2, 1, 1,那么60的约数有(2+1) (1+1) (1+1)=12(个) 19. 一个数所有约数之和一个数所有约数之和 等于先把每个质因数从0次幂一直加到其最高次幂,再把每个相应质因数幂的和相乘.若一个数分解为(a^m)*(b^n),则这个数所有约数的和为:(a^0+a^1+a^2+a^3+…+a^m)(b^0+b^1+b^2+b^3+…+b^n). 例如:(1)12=223,则12所有约数的和为：(2^0+2^1+2^2)(3^0+3^1)=74=28;(2)60=2235=(2^0+2^1+2^2)(3^0+3^1)(5^0+5^1)=74*6=168. 20. Trie 树21. 需要同时移动多少步A和B才同时指向一个节点长度为100的循环链表，指针A和指针B都指向了链表中的同一个节点，A以步长为1向前移动，B以步长为3向前移动，一共需要同时移动多少步A和B才能再次指向同一个节点？ 假定经过n步A、B再次相遇。则A经过的结点为n，B经过的结点为3n；此刻B必然比A多经过了整数倍的链表长度（圈的长度），假定经过了i倍的链表长度，则有3n-n=100i，即2n=100i；满足该等式的最小整数位i=2，n=100。即A经过了100个结点，B经过了300个结点，二者再次相遇。 也可以认为跑圈100m，A速度1m/s B速度3m/s，B比A多跑一圈耗时100/（3-1）=50s 22. 模拟加减乘注意 ^按位异或 、&amp; 按位与 、| 按位或 加法运算将一个整数用二进制表示，其加法运算就是：相异（^）时，本位为1，进位为0；同为1时本位为0，进位为1；同为0时，本位进位均为0。 故不计进位的和为sum = a^b，进位就是arr = a&amp;b,(与sum相加时先左移一位，因为这是进位）。完成加法直到进位为0.123int Add(int a, int b)&#123; return b ? Add(a^b, (a&amp;b)&lt;&lt;1) : a;&#125; 求相反数1234//求a的相反数：将各位取反加一int negative(int a)&#123; //get -a return Add(~a, 1);&#125; 减法运算a-b = a+(-b) 根据补码的特性，各位取反加1即可（注意得到的是相反数，不是该数的补码，因为符号位改变了）（上面用二进制实现的加减法可以直接应用于负数）1234int Minus(int a, int b)&#123; return Add(a, negative(b));&#125; 乘法运算原理上还是通过加法计算。将b个a相加参考二进制数转十进制数，每位有一个2次幂的权重，当该位为1时，加上 2^x 倍 a所以权重 a 不断 a&lt;&lt;=112345678910111213141516171819202122//正数乘法int Multi(int a, int b)&#123; int ans = 0; while(b)&#123; if(b&amp;1) ans = Add(ans, a); a = a &lt;&lt; 1; b = b &gt;&gt; 1; &#125; return ans;&#125;//正数除法int Divide(int a, int b)&#123; int coun = 0; while(a &gt;= b) &#123; a = Minus(a, b); coun = Add(coun, 1); &#125; return coun;&#125; 除法运算除法运算是乘法的逆。看a最多能减去多少个b， 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051//判断是否是负数，0，正数int isneg(int a)&#123; return a &amp; 0x8000;&#125;int iszero(int a)&#123; return !(a &amp; 0xFFFF);&#125;int ispos(int a)&#123; return (a&amp;0xFFFF) &amp;&amp; !(a&amp;0x8000);&#125;//处理负数的乘法和除法int My_Multi(int a, int b)&#123; if(iszero(a) || iszero(b)) return 0; if(isneg(a)) &#123; if(isneg(b)) return Multi(negative(a), negative(b)); else return negative(Multi(negative(a), b)); &#125;else if(isneg(b)) return negative(Multi(a, negative(b))); else return Multi(a, b);&#125;int My_Divide(int a, int b)&#123; if(iszero(b)) &#123; cout &lt;&lt; "Error!" &lt;&lt; endl; exit(1); &#125; if(iszero(a)) return 0; if(isneg(a)) &#123; if(isneg(b)) return Divide(negative(a), negative(b)); else return negative(Divide(negative(a), b)); &#125;else if(isneg(b)) return negative(Divide(a, negative(b))); else return Divide(a, b);&#125; 计算统中数值一律用补码来表示,因为补码可以使符号位和数值位统一处理，同时可以使减法按照加法来处理。原码 -&gt; 补码： 数值位取反加1 数值位不包括符号位补码 -&gt; 原码： 对该补码的数值位继续 取反加1补码的绝对值：（称为真值）正数的真值就是本身，负数的真值是各位（包括符号位）取反加1（即变成原码并把符号位取反） b -&gt; -b ： 各位（包括符号位）取反加1 旋转字符：字符串前面的部分排在后面“abcd”的旋转串是”abcd”，”bcda” … “dabc”首先目标串与原串长度要相等 可以设字符s+s，只要是s+s的子串都是旋转字符比如：&quot;abcd&quot;+&quot;abcd&quot;，即&quot;abcdabcd&quot;中寻找子串，时间复杂度是根据查找子串的时间来定的，所以如果是采用KMP则是O(N) 字符串提取出现的正负整数总和注意可以负负得正设置符号位positive，cur当前字符，num每一位不断往高位挪的积累数（字符串转化为数字），res数字总和 当cur为数字时，num = num * 10 + positive? cur:-cur; 当cur不为数字的时候，说明此时刚刚结束数字的转化，或者是开始部分没有数字，无论哪种都应该加上刚刚转化的数字num，并把num置零重新开始计数此时需要注意当cur为负号时，前一位为负则positive=true，否则为负；如果不是负号，则重置positive为正 字符串转换成int范围内数字字符串可以是只出现一个0，即 0字符串不能出现 - 、-0 、-02 、A12如果没有出现违法，只要检查是否每个字符都是数字就可以， 接下来进入判断，由于int范围是-2147483648 到 2147483647先把所有的数字都转为负数（转为负数可以不用再写一遍正数的，最后如果是整数再负负得正回去） 判断是否溢出，因为-214748364 * 10 + (-8) 刚好是最大整数先判断是否 ( res &lt; = -214748364 )|| (res == -214748364 &amp;&amp; cur &lt;= -8 )同时也要注意如果是正整数，则转换后不能大于 2147483647字符串replace a with b12345678910for(for...)&#123; if(a[i++]==b[j])&#123; j++ ; if(j==源串长)&#123; // 不用源串长-1，前面++过了 标记a串 [i-源串长,i] 为0或者某个特定符表示需要删掉 //（为了节省时间我们可以不删掉，只是不打印就可以） &#125; &#125; else j=0;&#125; 当a[i]=0而a[i-1]!=0时表示可以开始将前面积累的字符串打印了res = res + cur + to注意最后是如果末尾全是0，没有到不是0的过度，我们需要再手动把这部分转换加上 res += cur 计算连续出现字符的个数aabbbcc -&gt; a_2_b_3_c2这种连续计数，在字符变化后结束上一轮计数的都是一种做法，注意末尾部分没有转换需要手动加上 本题从第二个字符开始判断每个字符和前一个字符如果不一样，进入转换，记录数字个数，重置计数个数为1（因为当转换出现，和前个不一样，前个计数为1，例如ab，从b开始，a计数为1） 如果是 a_2_b_3_c2 -&gt; aabbbcc，求第5个字符是什么，此处是b由于有”_”，可以因此分别数字与字符，保存当前字符cur，记录数字，当数字大于需要求的位置则返回 判断是否每个字符只出现一次可以用Map但是如果只花费O(1)空间，只能使用堆排序，将数组排序对比前后是否相同 浮点数高精度幂替换空为%20先扫描一遍记录总长度为len+2*blank，再从后往前复制 一般挪动数组元素的，都需要从右往左复制 reverse字符串reverse整个串while(start&lt;end){ swap(c[start],c[end]); start++; end–;} reverse前后部分顺序abcde-&gt;deabc先翻转abc，再翻转de，再翻转整个串 变成回文串需要的最少字符str长为N，$N*N$ 的动态规划表 dp[i][j]表示str[i..j]这段字符最少需要多个字符使str[i..j]变成回文串 dp[i][j]=$$\begin{cases} 0, &amp; i=j\ 0 , &amp; str[i]=str[j] \quad and \quad |i-j|=2\ 1 , &amp; str[i]!=str[j] \quad and \quad|i-j|\geq2\ dp[i+1]dp[j-1] , &amp; str[i]=str[j] \quad and \quad |i-j|\geq2\ max{dp[i+1][j],dp[i][j-1]}+1 , &amp; str[i]==str[j] \quad and \quad |i-j|\geq2&amp;\end{cases}$$ 未完待续 判断最长左右括号()() 与 (())合法，返回最长的合法出现的括号位置 先检查( 和 )的数量是否相等 设dp[i]表示str[0..i]位置上，以str[i]结尾的最长有效括号长度 $….(()())为6$ str[i]==(，有效括号长度子串以)结尾，故dp[i]=0; str[i]==)，dp[i-1]代表str[i-1]结尾的最长有效括号长度，上一处没有被匹配过的位置i-1-dp[i-1]上如果是(，可以和str[i]凑成一对，此时dp[i]=dp[i-1]+2，同时dp[i-1]前面即str[i-2]之前的dp[i-2]也应该算上 最后求解 Max(dp[0..N-1]) 就是最终结果 计算字符串 4((3(-4)+-4*3))的结果每次碰到(就进入递归进入下一层，)就结束递归，并传递参数 (char [], 下一个位置位置 )数组返回(计算的结果, 结束的位置)1234567891011121314151617Recur(char [] , int i)&#123; while(i &lt; length &amp;&amp; ch[i] !=')')&#123; if( ch[i] 是数字 )&#123; pre = pre * 10 + ch[i] - '0'; i++; &#125;else if (ch[i] 是操作符 )&#123; 队列a入队pre 队列a入队ch[i] pre = 0; i++; &#125;else(ch[i] == '(')&#123; array = 递归本函数(ch,i+1) pre = array[0]; i = array[1]+1; &#125; &#125;&#125; 整数N的二进制全排中0左边必有1的个数按顺序拼接字符串使总结果字典序最小 先按照拼接的方式将数组排列，即 return (a+b)&gt;(b+a) 将排序后数组从头到尾组合起来 贪心算法，有详细需证明它的贪心策略是正确 新类型字符a、Aa、AA 中第k个字符是哪种类型的从k-1个字符开始往左对大写字母计数，碰到小写字母停止 根据奇偶判断k和k+1是AA，还是Aa，还是k+1是单独的a 回文段最少切割数dp[i]是子串str[i..len-1]需要切几次才能使str[i..len-1]全切成回文串，dp[0]是最后结果 从右往左，i初始为len-1 如果 str[i..j]是回文串,dp[i]=dp[j+1]+1，只需从str[j+1..len-1]寻找最经济的切割法 j 从 [i..len-1] 遍历，dp[i]=Min{dp[j+1]+1},i&lt;=j&lt;len且str[i..j]为回文串 快速判断是否是回文串的方法是回文子串长度的相同方法，设p[i][j]为i..j间是否是回文串的判定以下情况p[i][j]是回文串： str[i..j]长度为1 str[i..j]长度为2，且2个字符相等 子串str[i+1..j-1]是回文串（即p[i][j]=true），且str[i]==str[j]，最外面的两个字符串相等。 i 是从右往左，j是从i往右，所以i..j间长度是展开的便于计算p[i][j] 推荐阅读： 【阿里】算法工程师笔试题整理（13&amp;14年） 剑指offer题目及答案]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 警醒向条例]]></title>
    <url>%2F2019-01-23-Android%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83%E6%9D%A1%E4%BE%8B.html</url>
    <content type="text"><![CDATA[依然很简洁的条例，备忘用 本篇是搜集关于Android的仅以提醒作用的条例，见名知意。 相关注意事项推荐阅读《阿里巴巴的安卓手册》 条例 onActivityResult()发生在onResume()之前 onFinishInflate()在加载完成xml后执行：只有当自定义View，通过在XML中创建时才会调用。不从xml布局文件中解析的话，比如通过new方式创建，则不会执行该方法； foreach使用前需要判空 overridependingtransition()进入动画需要再startActivity之后，退出动画需要再finish后 view的调用过程:构造方法-&gt;onFinishInflate-&gt;onSizeChanged-&gt;onDraw 如果用户finish()方法结束了Activity，则不会调用onSaveInstanceState() getIntrinsicWidth()和getIntrinsicHeight() canvas的好处之一是旋转画布后旋转回来，以达到图像绘制部分的旋转，不用对坐标点进行转置 用transient关键字标记的成员变量不参与序列化过程 滑动冲突处理：可以根据滑动距离和水平方向形成的夹角；或者根绝水平和竖直方向滑动的距离差；或者两个方向上的速度差等 getParent().requestDisallowInterceptTouchEvent(false)请求父亲不要阻挡儿子 getSuggestedMinimumWidth的逻辑：View如果没有背景，那么返回android:minWidth这个属性指定的值，这个值可以为0；如果设置了背景，则返回背景的最小宽度和minWidth中的较大值。 Fragment的动画setCustomAnimations()对于反射取FragmentManager中置儿子为null的是有问题的，建议用Fragment自己的onCreateAnimation()函数 OOM：尽量避免使用帧动画，使用的话应尽量避免使用过多尺寸较大的图片 内存泄露：属性动画中的无限循环动画需要在Activity退出的时候及时停止，否则将导致Activity无法释放而造成内存泄露。view动画不存在这个问题； 当调用到onNewIntent(intent)的时候，需要在onNewIntent() 中使用setIntent(intent)赋值给Activity的Intent.否则，后续的getIntent()都是得到老的Intent launchMode为singleTask的时候，通过Intent启到一个Activity,如果系统已经存在一个实例，系统就会将请求发送到这个实例上，但这个时候，系统就不会再调用通常情况下处理请求数据的onCreate方法，而是调用onNewIntent方法 DiffUtil.DiffResult可以使RecyclerView不添加相同的条目，即部分更新 RelativeLayout如果cast到FrameLayout是不必要的，view就可以 自定义view，一定是this(context)、this(context,attr)、super(context, attr, defaltStyle)，注意需要手动调init()或者this(context, null)与this(context,attr,0) 小心使用ArrayList的subList [a, b) ，对生成对新列表的改变会改变原列表结构，可以在新列表前加final来阻止后续更改 RequestLayout() , Invalidate() , layout()的区别 如果需要addView的话，那么使用getLayoutParams是没用的，因为这个你自己新建的一个View，没有与父容器有任何关联。所以LayoutParams也需要你自己创建 contentInsetStart消除ToolBar在自定义布局中的左部白边 JSONObject中的getString()和optString()方法的区别在于optString()不报错 @Transient标志则不入数据库 overridePendingTransition转移 由于Activity的TaskMode不同所以onActivityResult在Activity的生命周期中执行的先后也是不同的，更有onCreate不会执行的情况，所以onActivityResult有时候提前结束收不到result。 调用startActivityForResult后onActivityResult立刻响应，而返回当前页时onActivityResult不响应主要是launchMode的问题： 第一种：当resultCode==0时，Activity的launchMode必须设置为”singleTask”或者singleInstance，否则就会出错。这是因为从Task的角度看，Android认为不同Task之间的Activity是不能传递数据的，所以不能使用NEW_TASK标识，但还是要调用forResult方法。 第二种：当resultCode！=0时，Activity的launchMode必须为standard（删除launchMode属性默认为standard模式），原因同上。 只有第一层fragment会收到onActivityResult 重写onBackPressed() 自定义回退事件可以避免按Back键自动设置resultCode为RESULT_CANCELED的问题 requestCode &gt;=0就好，随便用于在onActivityResult()区别哪个子模块回传的数据，每个区分开不同的requestCode resultCode 如果B子模块可能有几种不同的结果返回，可以用setResut(int resultCode, Intent intent)予以识别区分 @IntDef 注解自定义了一个 OrientationType 注解，用于防治用户随意设置数值。使用 @IntRange 方法将行列数限制在一个较合理的范围内。 1234@IntDef(&#123;VERTICAL, HORIZONTAL&#125;)public @interface OrientationType &#123;&#125; // 滚动类型@OrientationTypeprivate int mOrientation = HORIZONTAL; // 默认水平滚动 View child = recycler.getViewForPosition(i); //如果不存在的话 RecyclerView 会自动创建 RecyclerView要先移除再添加，这样会移除的 View 会被先放到缓冲区中，再添加 View 时就可以直接从缓冲区中把被移除的条目直接取出来使用了，而不用重新创建，以减少开销；如果先添加，由于缓冲区中没有可以使用的 View，会进行先创建，之后再添加到界面上，最后执行移除操作会导致有大量的 View 滞留在缓冲区中，会造成严重的性能浪费 对Vector、ArrayList在迭代的时候如果同时对其进行修改就会抛出 java.util.ConcurrentModificationException 异常 LinkedList在遍历循环中get(i)时间复杂度为O(n)，比ArrayList的O(1)性能差，使用有迭代器(Iterator)以及ForEach循环来对LinkedList进行遍历 对Activity来说，所有需要传递或接收的Activity不允许设置launchmode=”SingleTask”，只能设为标准模式，否则系统将在 startActivityForResult() 后直接调用 onActivityResult() Builder模式下，需要Builder单独列出的原因之一是，在使用单例模式时，每次都是用的同一个instance，而参数每次都需要重新new一个；不单独写一个Builder出来（第二重）是由于每次都重新new了一个XXX实例，当然参数也每次都不一样 12345678910111213141516171819202122232425//第一种class XXX&#123; //普通单例模式 private static XXX instance; public static XXX getInstance()&#123; if(instance == null)&#123; return new instance; &#125; &#125; private XXX&#123;&#125; class Builder()&#123; void set()&#123; ... return Builder.this; &#125; &#125;&#125;//第二种class XXX&#123; void set()&#123; ... return XXX.this; &#125;&#125; 基于引用计数的垃圾回收器无法处理循环引用导致的内存泄露问题，但是其在主流的JVM中很少，几乎所有的JVM都是采用引用对象遍历的方法，垃圾回收器都会处理循环引用潜在的问题 ThreadLocal、Volatile、synchronized、Atomic 的区别？如果只有一个i++;的时候，volatile和synchronized能否互换？volatile作为修饰变量的时候，变量自加中途可能发生线程调度，volatile 可以保证在一个线程的工作内存中修改了该变量的值，该变量的值立即能回显到主内存中，从而保证所有的线程看到这个变量的值是一致的。但是有个前提，因为它不具有操作的原子性，也就是它不适合在对该变量的写操作依赖于变量本身自己。就比如i++、i+=1;这种。但是可以改为num=i+1;如果i是一个 volatile 类型，那么num就是安全的，总之就是不能作用于自身。synchronized是基于代码块的，只要包含在synchronized块中，就是线程安全的。AtomicInteger，一个轻量级的synchronized。使用的并不是同步代码块，而是Lock-Free算法(一个死循环调用了底层的比较方法直到相同后才退出循环)，最终的结果就是在高并发的时候，或者说竞争激烈的时候效率比synchronized高一些。ThreadLocal，线程中私有数据。主要用于线程改变内部的数据时不影响其他线程，使用时需要注意static。再补一个，才学到的。利用clone()方法，如果是一个类的多个对象想共用对象内部的一个变量，而又不想这个变量static，可以使用浅复制方式。(查看设计模式原型模式) HashTable、SynchronizedCollection、ConcurrentHashMap、Vector 静态内部类单例原理，静态内部类单例在反序列化时会重新生成新对象因此需要抛出一个异常，反序列化是比正常创建新对象慢的 compare and set (CAS)，不断重新取值比较，可能会出现ABA问题（中途值被修改又还原） Message全程持有发送该消息Handler的引用 直到Handler处理完消息，Message回收释放实际上经常会出现的Diaglog泄漏就是，Dialog销毁的时候Activity已经销毁，所以会发不出那个Handler git commit –amend 可以修改提交 onScroll和onFling的区别在于，onFline是用于滑动的最后一下 不要重复 setListener，要使用 v.getId 来复用 Listener，不然会创建一堆 Listener 导致频繁 GC final与static final的区别是：final在一个对象类唯一，static final在多个对象中都唯一；一个既是static又是final的域只占据一段不能改变的存储空间，只有一份。 View的UI刷新，不会导致阻塞的原因是View 的绘制与 Java 代码的looper无关，而是由底层 SurfaceFlinger 自身的事件处理机制处理的 因为不光是gui，同样的道理在几乎所有编程领域里都是这样的，这背后是线程同步的开销问题。显然两个线程不能同时draw，否则屏幕会花；不能同时insert map，否则内存会花；不能同时write buffer，否则文件会花。需要互斥，比如锁。结果就是同一时刻只有一个线程可以做ui。那么当两个线程互斥几率较大时，或者保证互斥的代码复杂时，选择其中一个长期持有其他发消息就是典型的解决方案。所以普遍的要求ui只能单线程 onChildDraw影响触摸事件的接受顺序，同样影响绘制顺序 对组件 Activity 而言，viewRootImpl 的初始化在 onCreate 之后，onResume 之后，故在onCreate里开子线程更新UI不会报错 Glide中into()同一View，但显示不同的图片时（url不同）是使用的同一个Bitmap引用地址，只是像素不一样，在onResourceReady()里可以打印得到的bitmap的地址是一样的。这是因为BitmapPool会复用Request，可能会拿到擦除过的bitmap bitmap对象是通过env-&gt;NewOject(…)，所以是分配在虚拟机中的 RecyclerView.OnScrollListener()来监听RecyclerView的滚动距离，正常情况下是没有问题的，但是一旦RecyclerView的数据源变了的时候，比如筛选条件变了，需要清除之前的数据，然后重新添加新的数据到RecyclerView里面去，这时候记录的滚动距离就不准了；自定义RecyclerView的LinearLayoutManager来计算滚动距离，但是在滑动的时候特别消耗性能，滑动卡顿 AppCompatActivity获得Activity的方法Android get hosting Activity from a view Java的正则式首先需要Pattern.compile()后必须要调用find()或者matches()才能找到 在自定义控件的构造函数或者其他绘制相关地方使用系统依赖的代码，会导致可视化编辑器无法报错并提示，使用isInEditMode()可以解决在 在Android Studio下的文件app.iml已经制定了assets文件夹的属性，所以直接新建Directory即可 view.layout(l,t,r,b)在子线程中没反应，需要post()或者onAnimationStart中 getGlobalVisibleRect(globalRect)在没有被遮挡（超出屏幕）时和getLocationInWindow数值相同; getDrawingRect(drawingRect)和getLocalVisibleRect(localRect)没有遮挡时测试数值相同都是相对自己的坐标 include设置了id，会覆盖掉layout_activity_head布局文件中根layout的id 全面屏刘海屏的状态栏是很高的，在使用getLocationInWindow时需要特别注意，需要减去的状态栏高度会更高 onCreate期间调用setHasOptionsMenu，则该fragment在其后的onCreateOptionsMenu回调可以接受到设置标题栏的menu 在selector的xml写法中，vector图标不能用android:color/transparent来表明空图像，因为颜色是没有高度的（instrictWidth），并且导致后续高宽不会自动更新 直接在selector的xml中设置item为透明 &lt;item android:drawable=&quot;@android:color/transparent&quot; android:state_checked=&quot;false&quot; /&gt; 的写法是错误的，会导致高宽都变化为0，并且高宽不会自动更新。应该更改vector的文件的颜色为android:fillColor=”#00000000” 设置Acticity为全屏会获得和adjustNothing一样的效果，不会顶起布局 viewstub被inflate后会消失，包括它的id，可以使用android:inflatedId=”@id/vs_bottom”来规定它被inflate后叫什么，这样可以防止viewStub消失后其他引用它的布局失去了依赖 rxjava中的timer也可以加入自己的scheduler viewstub的布局参数应当写到viewstub内，比如margin值，写在layout内是无效的 ,但是padding是可以写在layout内的；ViewStub中不能用merge android中setOnClickListener会自动设置view为clickable = true，所以自定义的simpleAdapter添加setOnItemClick的时候需要自动添加view的clickable = true may not a tips: GreenDao主键自增类型必须是Long，而不是long。否则你会发现id永远为0，永远只有一个数据 onStop可能不会被调用（eg. 新Acitivity采用了透明主题，当前Actiivty不会回调onStop） 回到原Activity onRestart -&gt; onStart -&gt; onResume 每个View都可以onSaveInstanceState，并且onSaveInstanceState及onRestoreInstanceState是和onStop及onStart绑定的，onSaveInstanceState在onStop前，onRestoreInstanceState在onStart后 onNewIntent()—-&gt;onResart()——&gt;onStart()—–&gt;onResume(). 且当调用到onNewIntent(intent)的时候，需要在onNewIntent() 中使用setIntent(intent)赋值给Activity的Intent.否则，后续的getIntent()都是得到老的Intent。 singleTask的Actiivty被启用时，在其上的栈顶都会被清空（默认具有FLAG_ACTIVITY_CLEAR_TOP）85.fitsSystemWindows=true要慎用，很多坑。比如WebView中输入框获取焦点弹出软键盘时出现抖动，还有哪个View设置了fitsSystemWindows=true软键盘弹出时哪个View就会被顶上去； WindowManager.LayoutParams.FLAG_LAYOUT_NO_LIMITS不要用，会导致EMUI3.1的系统下面虚拟按键挡住布局 事件传递 12345678bool dispatchTouchEvent(MotionEvent ev)&#123; bool consume = false; if(onInterceptTouchEvent(ev))&#123; consume = onTouchEvent(ev); &#125; else &#123; consume = child.dispatchTouchEvent(ev); &#125;&#125; FragmentStatePagerAdapter和FragmentPagerAdapter都没有从viewGroup中removeView，而是transaction中detach/ remove掉了， 因此viewPager在保存不是fragment的时候需要警惕，其他view并不会像fragment一样刷新 PathMeasure的forceClosed参数对绑定的Path不会产生任何影响，例如一个折线段的Path，本身是没有闭合的，forceClosed设置为True的时候，PathMeasure计算的Path是闭合的，但Path本身绘制出来是不会闭合的。 - 均摘自 gcssloop forceClosed参数对PathMeasure的测量结果有影响，还是例如前面说的一个折线段的Path，本身没有闭合，forceClosed设置为True，PathMeasure的计算就会包含最后一段闭合的路径，与原来的Path不同。 Math.atan2(tan[1],tan[0])解释：tan[0] = cos = 邻边(单位圆x坐标)，tan[1] = sin = 对边(单位圆y坐标)，因此可以计算任意两点间的斜率夹角 pre和post，左乘进行行变换，右乘进行列变换，pre表明M左乘pre，poste表明M右乘pre，M表明矩阵 由于硬件加速的问题，PathMeasure中的getSegment在讲Path添加到dst数组中时会被导致一些错误，需要通过mDst.lineTo(0,0)来避免这样一个Bug measure.getMatrix(distance, matrix, PathMeasure.TANGENT_MATRIX_FLAG | PathMeasure.POSITION_MATRIX_FLAG);这个方法是用于得到路径上某一长度的位置以及该位置的正切值的矩阵 透明主题的坑： 坑一：透明主题的 Activity 如果弹出键盘，并且是 adjustResize 模式，在键盘弹出的一瞬间可以看到前一个 Activity 原因：键盘弹起时，Activity 重新计算了高度缩短了，而键盘弹起有一个动画，在动画没有执行完毕之前，键盘所占用的空间上没有别的布局只有 Window ，而 Window 是透明的因此就看到了上一个 Activity 尝试的解决方案：在动画执行完毕后，将 Window 的背景设置为不透明，但是失败了，见坑二 坑二：如果当前的 Window 背景带有透明度，在动态改变背景的时候会闪一下屏，如果 Window 的初始背景颜色没有透明度，动态改变背景很完美 原因：不详，目测是 Android 的 bug 解决方案：无。。。 坑三：也是由解决坑二造成的，我试图通过监听键盘弹起事件来手动调节布局，这样 Activity 不需要 resize 也就没有那个 bug，但是发现监听键盘弹起的方法基本都是监听 Activity 重新布局后对比高度来判断的，因此在 adjustNothing 状态下无效，值得一提的是，跟三弟交流发现他们钻了一个空子，当 Activity 为全屏状态时 adjustResize 是不生效的，但是可以监听到键盘弹出，所以相当于是adjustNothing的效果，但这种情况没法在我这个项目使用。 对window.addFlags需要在setContentView前 sqlLight数据库not null只针对于text为null的情况，但是text为&quot;&quot;时是可以插入的。 数据库的unique属性的列，insert()一旦失败，则批量都失败。此时可以用insert or replace，不会影响批量中其他数据的插入。 setRetainInstance(true)设置为true，表示 configuration change 的时候，fragment实例不会背重新创建，即重建时不会经过onDestroy和onCreate。 fragment 该方法也常常被用来处理 Activity re-creation 时候数据的保存。因此可以干很多骚操作，但即使是使用setRetainInstance还是有一定概率会被回收的，重新创建fragment后，requestCode和callback的关系就没有了。 fragment 该方法也常常被用来处理 Activity re-creation 时候数据的保存。因此可以干很多骚操作，但即使是使用setRetainInstance还是有一定概率会被回收的，重新创建fragment后，requestCode和callback的关系就没有了。 SharedPreferences是文件的一种，读写有一定的缓存策略，在内存中会有一份SharedPreferences文件的缓存，因此在多进程模式下其读写就变得不可靠。当面对高并发读写访问的时候，有很大几率会丢失数据，故不建议在进程间通信中使用SharedPreferences Messenger是一种轻量级的IPC方案，它的底层实现就是AIDL。Messenger是以串行的方式处理请求的，即服务端只能一个个处理，不存在并发执行的情形 rxjava2不接受null，会报错 DialogFragment的出现解决AlertDialog和PopupWindow随屏幕切换而消失的问题 123Window window = getDialog().getWindow(); window.setLayout(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.MATCH_PARENT); 等效于 12345DisplayMetrics dm = new DisplayMetrics();getActivity().getWindowManager().getDefaultDisplay().getMetrics(dm);if (null != window) &#123; window.setLayout(dm.widthPixels, dm.heightPixels);&#125; fragment的commit和commitAllowingStateLoss的区别 onSaveInstanceState()再onStop()前调用，而再Honeycomb前，是在onPause()前立即调用的，因为Honeycomb前对于回收来说一不可见Activity就被kill了，Honeycomb后Activity要在onStop后才能被kill掉 参见Fragment Transactions &amp; Activity State Loss Android 代码proguard混淆之后的错误log查看方法 项目目录的progurad下有一个mapping.txt文件 这是混淆后的名字和原名字的映射关系。在ADT安装目录的sdk\tools\proguard\bin下有三个工具，其中proguardgui.bat就是用来还原的图形化工具。 6.0后需要动态申请权限，7.0后需要通过FileProvider访问其他的权限。6.0后的动态申请权限，有可能会出现未授权时录音，Android录音数据前几千个字节为空的问题。 多进程在进程被kill掉的时候来不及正常调用onDestroy等流程，此时会通过binder通知其他进程自己死掉了，见Binder死亡通知机制之linkToDeath Fragment的可见性：onHiddenChanged()只会在对fragment进行show/hide变换时调用，第一次进入的时候不会调用，在使用beginTransaction().hide(Fragment)会被调用，而且是在onResume之前；而在viewpager中的fragment则完全不一样，需要手动调用setUserVisible(boolean)。 注意onHiddenChanged的特殊情况 Android Fragment可见性的判断与监听完全实现 ViewGroup默认情况不会调用onDraw()，它在init中会被设置成WILL_NOT_DRAW，这是从性能考虑，这样一来，onDraw就不会被调用了。如果我们要重要一个ViweGroup的onDraw方法，有两种方法： 在构造函数里面，给其设置一个颜色，如#00000000。 在构造函数里面，调用setWillNotDraw(false)，去掉其WILL_NOT_DRAW flag110.可以使用.adjustViewBounds(true)方法来设置宽度铺满屏幕的ImageView，但是对于小于17的版本不能正确显示 fragment重叠的问题：只需要在onSaveInstanceState中置空fragmnet状态即可-》outState.putParcelable(“android:support:fragments”, null); drawable.getConstantState().newDrawable()使用的是相同ConstantState下新建了一个drawable，和getResources().getDrawable(R.drawable.xxx)返回的对象一样。所有从本地资源读取图片资源getResources().getDrawable(R.drawable.xxx)的drawable都共享ConstantState，对一个drawable做更改会影响其他drawable持有相同ConstantState的drawable，eg. 修改alpha。可以使用drawable.mutate()来创建一个不共享的drawable。 关于Drawable的缓存机制应该了解的知识 很悲伤的是Rxjava中DisposableSubscriber的onStart()是在subscribeOn指定的线程上进行的（通常是子线程），它在整个任务的开始的时候调用。而onComplete()、onNext()、onError()是在observeOn指定的线程上进行的（通常是UI线程）。事实上，如果不指定线程，observe都将在主线程进行 注意RecycleView里都每个子项设置focusable=true的时候，这个时候设置点击就可能被最后一个抢掉了。 当一个Activity反常销毁重建的时候，请先查看下你的“不保留活动“是不是开启了。 dp和px的关系，是与屏幕像素密度为160的倍数而不同：像素密度为160时1px = 1dp117. 更多应该阅读的 CopyOnWriteArrayList ThreadPoolExecutor WeakHashMap Activity的SingleTask模式，使得onIntent可用 notifyItemChanged，因为DataSetChange可能会造成闪烁 Producer Extends Consumer Super &lt;? extends Fruits&gt; &lt;? super Apple&gt; 基于Window.ID_ANDROID_CONTENT给定id添加子View ArrayList ，LinkedList不同步 Vector同步 HashSet，LinkedHashSet,HashMap 不同步 HashTable 同步 同步的ArrayList = Collections.synchronizedList(new ArrayList(…)); SpannableString 数据库索引失败 Encapsulate Collection 学习JEE规范，去看JBoss源码；学习类加载器，就去看OSGI源码]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何快速搭建个人博客]]></title>
    <url>%2F2019-01-22-%E5%A6%82%E4%BD%95%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2.html</url>
    <content type="text"><![CDATA[记录搜集到的github Page搭建方法～ 首先如何快速搭成一个模型.. 利用 GitHub Pages 快速搭建个人博客 如果使用jekyll s命令调试本地搭建的博客，需要注意原作者在github上的一句话 哪里去找后续应该如何改动呢？ 打造个性超赞博客Hexo+NexT+GitHubPages的超深度优化 【持续更新】最全Hexo博客搭建+主题优化+插件配置+常用操作+错误分析 Github+hexo+next主题博客搭建教程]]></content>
      <categories>
        <category>小白教程</category>
      </categories>
      <tags>
        <tag>搭建博客</tag>
      </tags>
  </entry>
</search>
